# React

- JSX - JavaScript XML
- XML - Extensible Markup Language

1. ## Как работает React?

React создает виртуальный DOM. Когда состояние компонента изменяется, он сначала запускает алгоритм сравнения, который идентифицирует, что изменилось в виртуальном DOM. Второй шаг — согласование (reconciliation), при котором DOM обновляется результатами из сравнения.

DOM - Document Object Model (Модель объекта документа).

Виртуальный DOM в React - концепция создания и хранения в памяти облегченного виртуального представления реальной DOM (объектной модели документа).

Этот подход помогает оптимизировать производительность веб-приложений:

- Если данные или состояние React-компонента изменяются, вместо прямых манипуляций с реальной DOM-моделью обновляется виртуальная.
- Затем в виртуальной модели DOM вычисляется разница между предыдущим и обновленным состоянием компонента (с помощью diffing-алгоритма).
- После выявления различий React эффективно обновляет только необходимые части реальной DOM для отражения изменений.
- Использование виртуальной DOM позволяет React создавать динамичные и интерактивные пользовательские интерфейсы, обеспечивая при этом оптимальную эффективность и скорость рендеринга.

2. ## Преимущества использования React:

- Легко узнать, как визуализируется компонент, вам просто нужно взглянуть на функцию рендеринга.
- JSX упрощает чтение кода ваших компонентов. Также очень легко увидеть макет или то, как компоненты подключены/объединены.
- Вы можете рендерить React на стороне сервера. Это улучшает SEO и производительность.
- Легко тестировать. (Т.к приложение разбито на отдельные компоненты, что позволяет локализировать возможные проблемы)

3. ## В чем разница между презентационным компонентом и компонентом-контейнером?

Презентационные компоненты связаны с тем, как компоненты выглядят.
Обычно они получают данные и колбэки через пропсы.
Эти компоненты редко имеют собственное состояние, но когда они это делают,
это обычно касается состояния пользовательского интерфейса, а не состояния данных.
Когда ваш компонент просто получает пропсы и отображает их на странице,
это компонент без состояния, для которого можно использовать чистую функцию.
Их также называют тупыми компонентами (dumb components) или презентационными компонентами.

Компоненты-контейнеры заботятся о том, как все работает.
Эти компоненты предоставляют данные и поведение презентационным или другим компонентам-контейнерам.
Они определяют действия и предоставляют их как функции обратных вызовов презентационным компонентам.
Они также часто имеют состояние, поскольку служат источниками данных.

4. ## Каковы различия между компонентом класса и функциональным компонентом?

Компонент класса использует синтаксис класса ES6 и расширяет компоненты React
с помощью метода рендеринга, который возвращает элементы React.
Функциональные компоненты с хуками — это обычные JavaScript функции,
которые также возвращают элементы React (JSX).
До появления хуков функциональные компоненты не могли иметь состояния.

5. ## В чем разница между состоянием и пропсами?

Состояние — это структура данных, которая начинается со значения по умолчанию при монтировании компонента.
Он может видоизменяться со временем, в основном в результате пользовательских событий.
Пропсы (сокращение от properties, props) — это конфигурация компонента.
Они получены сверху из компонента родителя и неизменяемы (иммутабельны).
Компонент не может изменять свои пропсы.
Функции обратного вызова также можно передавать в качестве пропсов.

6. ## Какие существуют методы жизненного цикла?

TODO:

_componentWillMount_ (устаревший) — чаще всего используется для настройки приложения в корневом компоненте.

_componentDidMount_ — здесь вы можете сделать всю настройку, которую вы не смогли бы сделать без DOM, и начать получать все необходимые вам данные.
Кроме того, если вы хотите настроить прослушиватели событий и т. д.,
этот хук жизненного цикла — хорошее место для этого.

_componentWillReceiveProps_ (устаревший) — этот метод жизненного цикла действует на определенные
изменения пропсов, чтобы вызвать переходы состояний.

_shouldComponentUpdate_ — если вы беспокоитесь о потраченных впустую рендерах, _shouldComponentUpdate_ —
отличное место для повышения производительности, поскольку оно позволяет предотвратить повторный рендеринг,
если компонент получает новый проп. _shouldComponentUpdate_ всегда должен возвращать логическое значение, и на его основе будет определяться, будет ли компонент перерисован или нет.

_componentWillUpdate_ (устаревший) — используется редко. Его можно использовать вместо _componentWillReceiveProps_ для компонента, у которого также есть _shouldComponentUpdate_ (но нет доступа к предыдущим значениям пропсов).

_componentDidUpdate_ — также обычно используется для обновления DOM в ответ на изменение пропсов или состояния.

_componentWillUnmount_ — позволяет отменить любые исходящие сетевые запросы или удалить все прослушиватели событий, связанные с компонентом. Вызывается перед размонтированием компонента.
